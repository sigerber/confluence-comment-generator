package org.github.sigerber.confluence.comment.generator

import com.beust.klaxon.JsonObject
import com.beust.klaxon.obj
import com.beust.klaxon.string
import org.github.sigerber.confluence.comment.generator.MarkovGenerator.generateParagraphs
import org.github.sigerber.confluence.comment.generator.MarkovGenerator.trainMarkovChain
import com.xenomachina.argparser.ArgParser
import com.xenomachina.argparser.runMain
import org.jsoup.Jsoup
import java.lang.System.*

private val DO_NOT_IMPERSONATE = "DO_NOT_IMPERSONATE"
private val UNDEFINED_ID = -1L

fun main(args: Array<String>) {

    val consoleColumns = getProperty("LINES", "160").toInt()
    try {
        Arguments(ArgParser(args)).runMain("confluence-comment-generator", columns = consoleColumns) {

            val confluenceClient = ConfluenceClient(host, username, password)
            setupGeneratedCommentFooter(confluenceClient)

            val (page, contentIdType) = confluenceClient.fetchPageOrParentPageOfComment(contentId)

            val trainingTextWithHtml = if (impersonate == DO_NOT_IMPERSONATE) {
                collatePageAndComments(confluenceClient, page)
            } else {
                collatePageAndImpersonatedUserContent(confluenceClient)
            }

            if (trainingTextWithHtml.isEmpty())
                throw RuntimeException("No training text found. Was the page empty? Are you impersonating a non-existent user or someone who has nothing to say?")

            val trainingText = trainingTextWithHtml.map(::removeHtmlTags)
            val chain = trainMarkovChain(trainingText, gramSize)

            val commentText = generateParagraphs(chain, minParagraphs, maxParagraphs, minSentences, maxSentences, separator = "<p></p><p>")

            if (cheat) {
                println("Not feeling lucky? Here's your comment: \n$commentText\n")
                println("Post this now? (y/N)")
            } else {
                println("Are you sure you want to do this? (y/N)")
            }

            val answer = readLine()

            if (yes(answer)) {
                if (contentIdType == "comment") {
                    confluenceClient.replyToComment(commentText, contentId, page)
                } else {
                    confluenceClient.postCommentToPage(commentText, page)
                }
                println("Well played, sir!")
            } else {
                println("Chicken! Would have printed this comment: \n$commentText")
            }
        }
    } catch (e: Exception) {
        println("Error: ${e.message}")
        exit(1)
    }
}

private fun yes(answer: String?) = answer == "y" || answer == "Y"

private fun Arguments.setupGeneratedCommentFooter(confluenceClient: ConfluenceClient) {
    if (impersonate == DO_NOT_IMPERSONATE) {
        confluenceClient.commentFooter = "<p></p>---<br>Generated by <a href='https://github.com/sigerber/confluence-comment-generator'>'Confluence Comment Generator'</a>"
    } else {
        confluenceClient.commentFooter = "<p></p>---<br>Generated by <a href='https://github.com/sigerber/confluence-comment-generator'>'Confluence Comment Generator'</a> - <i>in the style of $impersonate</i>!"
    }
}

private fun Arguments.collatePageAndImpersonatedUserContent(confluenceClient: ConfluenceClient): List<String> {
    val cql = if (includePages) {
        "creator=$impersonate AND (type=page or type=blogpost or type=comment)"
    } else {
        "creator=$impersonate AND (type=blogpost or type=comment)"
    }

    return if (impersonate == "jausten") {
        val inputStream = Thread.currentThread().contextClassLoader.getResourceAsStream("eggs.txt")
        listOf(inputStream.bufferedReader().use { it.readText() })
    } else {
        confluenceClient.searchForContent(cql).filterNot { it.contains("Generated by") }
    }
}

private fun collatePageAndComments(confluenceClient: ConfluenceClient, page: JsonObject): List<String> {
    val bodyTextWithHtml = page.obj("body")?.obj("view")?.string("value")!!
    val cleanBodyText = removeHtmlTags(bodyTextWithHtml)

    val containerId = page.string("id")!!.toLong()

    val commentsWithHtml = confluenceClient.fetchPageComments(containerId).filterNot { it.contains("Generated by") }
    val cleanedComments = commentsWithHtml.map(::removeHtmlTags)

    return listOf(cleanBodyText) + cleanedComments
}

private fun removeHtmlTags(html: String) = Jsoup.parse(html).text()

private class Arguments(parser: ArgParser) {
    val host by parser.storing("-H", "--host",
            help = "Confluence host name. Do not include 'http(s)' (Default 'confluence'.").default("confluence")

    val username by parser.storing("-u", "--username",
            help = "Confluence username")

    val password by parser.storing("-p", "--password",
            help = "Confluence password")

    val gramSize by parser.storing("-g", "--gramSize",
            help = "Gram size to use in training the model. (Default 3)") { toInt() }.default(3)

    val contentId by parser.storing("-c", "--contentId",
            help = "The identifier of the content the generated comment will be posted in reply to.") { toLong() }.default(UNDEFINED_ID)

    val impersonate by parser.storing("-i", "--impersonate",
            help = "If provided, will base the generated comment off content authored by the given user, rather than just content on the target page")
            .default(DO_NOT_IMPERSONATE)

    val includePages by parser.flagging("--includePages",
            help = "When impersonating, include pages as well as comments in the model training")

    val cheat by parser.flagging("--cheat",
            help = "Print the generated comment BEFORE posting it. Wuss.")

    val minSentences by parser.storing("--minSentences",
            help = "The minimum number of sentences to generate per paragraph (default 1)") { toInt() }.default(1)

    val maxSentences by parser.storing("--maxSentences",
            help = "The maximum number of sentences to generate per paragaph (default 7)") { toInt() }.default(7)

    val minParagraphs by parser.storing("--minParagraphs",
            help = "The minimum number of paragraphs to generate per comment (default 1") { toInt() }.default(1)

    val maxParagraphs by parser.storing("--maxParagraphs",
            help = "The maximum number of paragraphs to generate per comment (default 3") { toInt() }.default(3)
}
